# get_next_line

42 Tokyo の課題として実装した、  
**ファイルディスクリプタから 1 行ずつ効率よく読み込む関数**です。

C 言語のメモリ管理、バッファリング、静的変数の扱い、EOF 処理など  
システムプログラミングの基礎を深めました。

---

## 📌 プロジェクト概要

### ✔ 関数プロトタイプ
```
char *get_next_line(int fd);
```

### ✔ 目的  
- ファイル・標準入力・パイプなどの  
  **ファイルディスクリプタから 1 行ずつ読み込む**  
- 改行（`\n`）か EOF に到達するまで読み続ける  
- 次に呼ばれたときは**続きの位置から再開**  
- 返り値は **ヒープに確保** して返す

---

## 🧱 技術スタック
- **C 言語**
- **read() システムコール**
- **静的変数によるストレージ管理**
- **文字列操作（libft の応用）**
- **メモリ管理（malloc / free）**
- **バッファ処理と連結操作**

---

## 🧩 実装のポイント

### ✔ 1. `read()` を使ったバッファリング
`BUFFER_SIZE` 分だけ読み込み、  
改行が見つかるまで読み足していく。

### ✔ 2. 静的変数による「残りの文字列」の保存
前回の呼び出し時に処理しきれなかったデータを  
**static char *stash** として保持。

例：  
```
aaaa\nbbbb
```
1回目 → "aaaa\n" 返す / "bbbb" をstashに残す  
2回目 → "bbbb" 返す

### ✔ 3. 改行の探索
- 改行を含むまで読み込む  
- 改行より前の部分を「返す行」  
- 改行以降を「次回以降のstatic変数」に保存

### ✔ 4. メモリリーク防止
- 読み込み終了後にストレージを全部 free  
- 行単位で独立した malloc  
- 例外時の全解放

### ✔ 5. EOF / エラー処理
- EOF で読み込むものがなければ `NULL`
- read が -1 のときも `NULL`

---

## 🧠 学んだこと

### ✔ 静的変数の本質的な動き  
関数をまたいで状態を保持する仕組みを理解。

### ✔ ファイル入出力の基本  
`read()` の戻り値が  
- 0 → EOF  
- -1 → エラー  
- `>`0 → 読み込んだバイト数  

### ✔ メモリ安全性  
- 残メモリの分割  
- 使用済みバッファの free  
- 例外時の early return でもリークが出ない設計

---

## 🔍 苦労した点 & デバッグ

### ● バッファとストレージの連結でのリーク  
- 一時変数で受けて free  

### ● EOF 直前の境界処理  
改行がない行でも正しく返す必要がある。

### ● static変数のfree
テキストファイルが空だったり、EOFになった時に、static変数にはNULLが入っており、それ自体はfreeされていないため、valgrindにおいて'still reachable'という指摘を受けてしまうので、その際にstatic変数をfreeする処理を挟まなければならなかった。
